# Vue3

公式ドキュメントのメモ書きを基本に、周辺知識を雑多に書いていく。

## Vueアプリケーション基礎

- 全てのVueアプリケーションはcreateAppでアプリケーションインスタンスを作成するところから始まる。(app)
  - グローバル（コンポーネント、ディレクティブ、プラグインなど）を登録するために使われる。
  - ルートコンポーネントの設定に使われる。レンダリングの起点として使われ、DOM要素にマウントする。(vm)
- コンポーネントインスタンス
  - コンポーネントは名前付きの再利用可能なインスタンス
  - コンポーネントを使用するにはVueが認識できるよう、グローバルかローカルのどちらかで登録する必要がある。
    - グローバル登録は`app.component('component-name', { ... })`でサンプルでは記述しているが、一般的には文字列テンプレートではなくSFCを使用する。
    - 子コンポーネント側で`<slot></slot>`プレースホルダを用意しておくことで、コンポーネント呼び出し時にタグ内部の要素をそのまま受け取れる。
  - プロパティ
    - data
      - インスタンスを介して公開される
      - オブジェクトを返す関数であり、そのオブジェクトをVueがリアクティブシステムでラップしてコンポーネントインスタンスの$dataに格納する
      - 後から$dataにプロパティを追加した場合、リアクティブシステムによって追跡されない
      - トップレベルのdataプロパティの名前に`$`または`_`ではじまる名称は避けるべき（Vueが利用する）
    - provide/inject
      - provideはオブジェクトを返す関数であり、全ての子階層に依存関係を提供するプロバイダとして機能できる
      - 長距離のpropsのように使用できる
        - 親コンポーネントは、提供したプロパティが子孫のどこで利用されるか知る必要がない
        - 子コンポーネントは、注入されたプロパティがどこから提供されたのか知る必要がない
  - 組み込みプロパティ
    - $props,$el,$options,$parent,$root,$slots,$refs,$attrs
  - 組み込みメソッド
    - $emit
      - 親コンポーネントにイベントを発行できる
      - 以下は公式サンプルコード抜粋
        - 子 `<button @click="@emit('enlargeText')">`
        - 親 `<child-component @enlarge-text="postFontSize += 0.1">`
      - サンプル2（引数あり）
        - 子 `<button @click="@emit('enlargeText', 0.1)">`
        - 親1 `<child-component @enlarge-text="postFontSize += $event">`
        - 親2(メソッド名を指定して第一引数で受け取る) `<child-component @enlarge-text="onEnlargeText">`
    - $watch,$forceUpdate,$nextTick
  - コンポーネントオプション
    - methods
      - Vueがmethodsの`this`を自動的に束縛して、常にコンポーネントのインスタンスを参照する。
        - thisの参照が混乱するため、アロー関数の利用は避ける
      - テンプレートから呼び出されるメソッドはデータの変更や非同期処理の発火などの副作用があってはならない。代わりにライフサイクルフックを使うべき。
    - props
      - プロパティ、コンポーネントのカスタム属性
    - emits
      - 発行されたイベントを一覧できる
    - computed
      - リアクティブな依存関係に基づいてキャッシュされるため、パフォーマンスが良い。
    - watch
      - データの変更に反応するためのより汎用的な方法（基本的にはcomputedが良い）
    - inject
    - setup
  - ライフサイクルフック
    - 全てのライフサイクルフックは呼び出し元であるアクティブなインスタンスを指す`this`コンテキストとともに呼ばれる。
    - アロー関数はthisを持たないため使えない
    - ライフサイクルフックの一覧
      - beforeCreate
      - created、インスタンス作成後
      - beforeMount
      - mounted
      - beforeUpdate
      - updated
      - beforeUnmount
      - unmounted
- テンプレート構文
  - Mustache構文（二重中括弧）
    - `{{ msg }}`
    - `v-once`ディレクティブを使うことで値の変更の影響を受けないレンダリングも可能
  - `v-html`ディレクティブで文字列ではなく生のHTMLを内部に展開可能
  - MustacheはHTML属性内部で使用できないため`v-bind`ディレクティブを使用する
    - nullやundefinedであれば属性が消える
  - 単一のJavaScript式が動作する
  - イベントハンドリング
    - `v-on`ディレクティブでDOMイベントの購読、イベント発火時のJS実行が可能。JS式、method名、インラインJS式を指定可能。
    - インラインステートメントに`$event`を使うことでメソッドにDOMイベントを渡せる。
    - カンマ区切りで複数のメソッドを設定でき、両方実行できる。
    - イベント修飾子をdot区切りで指定可能
      - `.stop`,`.prevent`,`.capture`,`.self`,`.once`,`.passive`
  - ディレクティブの省略記法
    - `v-bind:`は`:`で記述できる
    - `v-on:`は`@`で記述できる
  - クラスのバインディング
    - オブジェクト構文
      - `class`属性と共存可能な`:class`ディレクティブを定義し、要素にキーにクラス名、値に真偽値を持つオブジェクトを定義する
    - 配列構文
      - `:class`に配列を渡してクラスのリスト適用も可能、配列の一部にオブジェクトをもたせてオブジェクト構文を併用することも可能
  - スタイルのバインディング
    - オブジェクト構文
      - `:style`でオブジェクトで定義したスタイルを適用可能、プロパティ名はキャメルケースでもケバブケースでも可
    - 配列構文
      - 複数のオブジェクトを含めた配列を適用可能
  - 条件付きレンダリング
    - `v-if`、`v-else-if`、`v-else`ディレクティブを利用して分岐可能。
    - `<template>`を使うことで描画されないタグでの分岐も可能。
    - 常に描画され、`display`CSSプロパティを切り替えるだけのifとして`v-show`がある。これに`v-else`は使えない。
    - `v-if`と`v-for`が同要素に使われる場合、`v-if`が先に評価される。（非推奨）
  - リストレンダリング
    - `v-for`でリストやオブジェクトの繰り返しレンダリングが可能
  - フォーム入力バインディング
    - input、textarea、select要素に双方向データバインディングを付与するのに`v-model`を使用可能
    - `v-model`は常に現在アクティブなインスタンスの`data`を信頼できる情報源として扱い、フォーム要素の初期値を無視する
    - `v-model.lazy`で`input`イベント後ではなく`change`イベント後に値を同期するようにできる
    - `v-model.number`で値を数値にキャストできる
    - `v-model.trim`で空白を除去できる
    - `v-model="hoge"`をコンポーネントに適用する場合`:model-value="hoge" @update:model-value="hoge = $event"`と等価であり、子では`modelValue`プロパティのバインドと`update:modelValue`イベントの発行が必要。
  - 動的なコンポーネント指定
    - `<component :is="componentName"></component>`で登録されたコンポーネントの名前を指定する、またはコンポーネントのオプションオブジェクトを指定できる。
    - 類似で、要素の配置制限を回避するために`is`（:isではない）を使うこともある
- 単一ファイルコンポーネント（SFC）
  - テンプレート、ロジック、スタイルを1つのファイルにまとめることができる特別なファイル形式（\*.vue）
    - `<template>`、`<script>`、`<style>`のトップレベル言語ブロックで構成される（必要に応じてカスタムブロックもある）
      - `<script setup>`はSFCでCompositionAPIを使用するシンタックスシュガー（糖衣構文）
        - 内部のコードはコンポーネントの`setup()`関数の内容としてコンパイルされる
        - インスタンス作成のたびに実行される
        - 名前空間付きコンポーネント
          - 単一ファイルから複数コンポーネントをインポートするときに`<Foo.Bar>`のように参照可能
        - `props`と`emits`を宣言するには`defineProps`と`defineEmits`のAPIを使用する必要がある（`<script setup>`内では自動的に使える）
          - TypeScriptのみの機能としてリテラル型の引数を渡すことで純粋な型の構文を使っての宣言が可能
            - 欠点としてpropsのデフォルト値を宣言できない問題があるが`withDefaults`コンパイラマクロを使用することで解決可能
        - プロパティを明示的に公開するには`defineExpose`を使用する
        - 通常の`<script>`と併用も可能
      - lang属性でプリプロセッサ言語を`<script lang="ts">`でTypeScriptを指定するように指定可能
        - 類似でstyleにscss、templateにpugを指定可能
      - src属性でコンポーネントの各ブロックの内容を分離可能（script setupは不可）
      - 各ブロック内では各言語のコメント構文を使用可能（トップレベルはHTML）
  - SFCはファイル名でコンポーネント名を自動推論する（`FooBar.vue`なら`<FooBar/>`になる）
- CompositionAPI
  - setup
    - setupはprops解決後に実行され、CompositionAPIのエントリポイントとして機能する。
    - thisは参照しないべき。
    - data,computed,methodsは解決前のため利用できない。
    - propsとcontextを受け付ける関数であるべき。`setup(props)`
    - setupから返される全てのものは、コンポーネントの残りの要素（computed,methods,ライフサイクルフックなど）およびtemplateに公開される
  - `ref`によるリアクティブな変数
    - ref関数によってあらゆる変数をリアクティブにできる
    - ref関数は引数を受け取り、それをvalueプロパティを持つオブジェクトでラップして返す。
    - プリミティブに対しては`ref`を使い、オブジェクトに対しては`reactive`を使う。オブジェクトのプロパティをリアクティブにしたければ`toRefs`を使う。
  - TypeScript
    - 型をつける必要がないもの？
      - props引数（propsコンポーネントオプションから型推論するため）
      - ref（初期値から推論）
      - reactive（なんぞ？）
      - 算出プロパティ
    - 型付けが有効？
      - イベントハンドラ

## 所感

色々読んだが、Vue3はコミッター陣も含めてまだ模索中な部分が多いプロダクトのように感じる。

Vue2で得た色々な知見を元に

1. TypeScriptへの親和性を高めて型安全性を上げた
2. Provide/Injectを本格採用した（前から存在はしていた）
3. Teleportを導入してDOMツリーと概念的ツリーの矛盾に対処しやすくした
4. Vuex適当に使うとやべえの意識が強くある

あたりが共通認識ぽい。
私もVue2で3,4あたりの問題意識はあったので、持っている人が多かったということと思われる。解決策の1つとして2があるっぽい。

コンポーネント設計のプラクティスも定まったものはないどころか、紹介しているところも少ない。
Nuxt.jsの設計や偉い人のプレゼンも参考にしつつ独自の何かを作っていくしかなさそう。

Atomic Designェ…

