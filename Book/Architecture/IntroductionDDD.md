# ドメイン駆動設計入門

エリック・エヴァンスのDDD本はあまりに難解な文章で書かれており、代わりにDDD理解のため手にとった本。
筋道立てて読者に解説することを意識している本だと感じた。
基本的にDDDはオブジェクト指向を少し具体化して名前を与えた概念のように感じた。
ただDIなど明示されていない概念を各所で使用しているように思う。軽くそうした概念の名前について触れておいて貰えると追加で検索して知識を深めやすそうだと感じた。

## ドメインの概念

基本的なドメインの概念を表現する手段は３つ

1. 値オブジェクト
2. エンティティ
3. ドメインサービス

ドメインの概念を用いて組み立てられるもの

1. ユースケース

## ドメインモデルとは

> ドメインは「領域」の意味を持った言葉

## 値オブジェクト

システム固有の値を表現することを目的としたオブジェクト(クラス)のこと。
オブジェクト指向的な側面もある。

文字列リテラルのような「値」は不変であり「値オブジェクト」はそれに類する概念であり、一般的な「オブジェクト」と違う。

値は代入（交換）によってのみ変更を表現可能である。
値は等価性によって比較される。

値オブジェクトは値であるため、`1 == 1`と同じように`a == b`というように比較可能であるべき。
`a.value == b.value`ではいけない。

値オブジェクトにすべきかどうかの一つ判断基準は
1. そこにルールが存在しているか
2. それ単体で取り扱いたいか

## エンティティ

固有の同一性（identity）で識別するオブジェクト（クラス）のこと

エンティティはライフサイクルを持つ点で値オブジェクトと異なる。
基本的にプロパティの値は可変だが、不変にできるならその方が可読性は上がる。

## サービス

> ソフトウェア開発の文脈で語られるサービスはクライアントのために何かを行うオブジェクト

DDDの文脈ではドメインサービスとアプリケーションサービスがある。
サービスは状態を持たない。

### ドメインサービス

値オブジェクトやエンティティに記述すると不自然になってしまう「ふるまい」をドメインサービスに記述して解決する。
複数のドメインオブジェクトを横断するような操作によく見られる。

ドメインサービスに書きすぎてドメインモデル貧血症にならないように注意が必要。

ドメインサービスは値オブジェクトやエンティティと組み合わせて利用される。

ドメインサービスの関心事は値オブジェクトやエンティティと同一の括りであり、本来データストアは存在しない。
入出力を伴う処理を取り扱わないようにするべきという考えもある。

入出力操作はアプリケーションの関心事であり、ドメインの概念や知識のコード上の表現であるドメインオブジェクトがデータストア操作をすることは望ましくない。

#### ドメインサービスの命名

命名規則としては以下３種のどれかになるケースが多い

- ドメインの概念
  - シンプルだがコーディング時に意識が必要になる
- ドメインの概念 + Service
  - e.g. XxxDomain.Services.XxxService
- ドメインの概念 + DomainService
  - 冗長だが勘違い防止には最強

### アプリケーションサービス

ドメインオブジェクト3種を協調させてユースケースを実現するオブジェクト。

アプリケーションサービスはドメインモデルを扱うが、戻り値としてドメインオブジェクトを渡すのは将来的に大きな危険が伴う。

これを解決する手段としてDTO（DataTransferObject）がある。ドメインオブジェクトをDTOに変換する処理はアプリケーションサービスが担う。

#### 凝集度という考え方

すべてのインスタンス変数はすべてのメソッドで使われるべき、使われるほど凝集度が高く好ましいとされる。
クラスを分割することで凝集度を高めるのが最も簡単なアプローチ。

## リポジトリ

一般的なリポジトリという言葉の意味は「保管庫」
データにまつわる処理を分離し、ソフトウェアの柔軟性に寄与するパターン。

データの永続化と再構築を抽象的に扱うためのオブジェクト。
具体的なSQLなどはここに記述して良い。
オブジェクトをデータストアに保存する際には、直接ではなくリポジトリに依頼する。

リポジトリはドメインの概念を由来とするものではないが、ドメインと無関係でもない。
リポジトリの存在がドメインオブジェクトを際立たせる。

リポジトリはインターフェース（抽象）で定義される。（本体となるリポジトリも定義する）
DIの概念が含まれていそう。

### インターフェースについて

テストを記述する際などに抽象化されているとダミーのリポジトリを注入しやすい。

## 依存関係

クラスAの中でクラスBを使用（参照）している場合、クラスAはクラスBがなければ成り立たず、クラスBに依存していると言える。
こうした以前はプログラムで自然と発生する。

抽象型を用いた依存関係逆転の原則（DIP）について紹介。

> 上位レベルのモジュールは下位のモジュールに依存してはならない。
> どちらも抽象に依存すべきである

> 抽象は実装の詳細に依存してはならない。

人間に近いものを上位、機械に近い具体的な処理を下位としている。
たとえばApplicationServiceはRepository（DB操作）より上位レベル。

抽象型（インターフェース）は利用するクライアントが要求する定義。

### Service Locatorパターン

ServiceLocatorと呼ばれるオブジェクトに依存解決先となるオブジェクトを事前に登録しておき、これを経由して各所で必要なインスタンスを取得するパターン。

#### アンチパターンと言われる理由

1. 依存関係が外部から見えづらくなる
  - クラスのプロパティやコンストラクタやメソッドにServiceLocatorの存在が書かれないため、見えづらくなる。
    - 事前にServiceLocatorの設定が必要なことが、クラスの定義を見てもわからない。
2. テストの維持が難しくなる

### IoC Containerパターン（DI Container）

前提としてDependency Injectionパターンの知識が必要。

DependencyInjectionパターンの問題となる、依存するオブジェクトのインスタンス化をあちこちに記述する必要がある問題点を解決するのがIOC Containerパターン。
例えばあらかじめServiceCollectionに依存解決の設定を登録しておき、依存を含むインスタンスの生成自体を担うオブジェクトを作る。

#### Dependency Injectionパターン

コンストラクタやメソッドで依存先を注入する。

## ファクトリ

作る知識に特化したオブジェクト。
オブジェクトの生成はときに複雑な手順を必要とするが、そういった手順それ自体をオブジェクト化し、オブジェクト生成の責務を負わせたオブジェクト。
道具（オブジェクト）を作成する工場、になぞらえたネーミング。

メソッドがファクトリとして機能することもある。

ファクトリはドメイン由来の概念ではないが、ドメインを表現するために必要であり、ドメインの設計を構成する要素と言える。

## データの整合性

トランザクションの取り回し方についての確認。

C#では、トランザクションスコープという、トランザクションを行う範囲を定義するブロックを定義することで依存性の問題に触れずに解決が可能だが、これは言語に依存した解決法。

Javaではアスペクト指向プログラミング（AOP: Aspect Oriented Programming）に基づいたアプローチで実現している。

ユニットオブワークという、オブジェクトの変更を記録するパターンも選択肢になる。

基本的にはAOPが優れている。



## 豆知識

- MVCのコントローラの責務は入力の変換。ゲームコントローラと一緒。
