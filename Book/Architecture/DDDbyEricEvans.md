# エリック・エヴァンスのドメイン駆動設計

全体的に非常に読みにくい書籍だった。  
それはまるで、Google翻訳にかけた英文を読んでいるかのようであり、また技術書というより随筆を読んでいるような気分にさせられた。


## ドメインとは

> 全てのソフトウェアプログラムは、それを使用するユーザの何らかの活動や関心と関係がある。ユーザがプログラムを適用するこの対象領域が、ソフトウェアのドメインである。  
> 例えば、航空会社の予約プログラムのドメインは、実際の航空機に登場する現実の人々を含んでいる。  
> 会計プログラムのドメインは金銭と財務である。  
> ソースコード管理システムのドメインは、ソフトウェア開発そのものである。  
> ドメインモデルとは特定の図ではなく、図が伝えようとしている考え方である。

## 継続的学習

チームメンバー、開発者、ドメインエキスパート（その道のプロ）が共通の言語を共有することによって、全作業を効率的に行うことができる。

## ユビキタス言語

- モデルを言語の骨格として使用すること
- その言語を厳格に用いることをチームに約束させること
- 同一の言語を使用すること
- 会話の中で用語が混同されていたら、普通の単語の意味について認識を合わせるのと同じやり方で解決すること。
- ユビキタス言語における変更は、モデルに対する変更であると認識すること。
- ドメインエキスパートは、ドメインについての理解を伝えるには不適切な用語に異議を唱えるべき
- 開発者は、設計を妨害することになる曖昧さや不整合に異議を唱えるべき

## 一つのチームに一つの言語

ドメインエキスパートがモデルを理解できないとしたら、モデルに問題がある

## 書かれた設計ドキュメント

> エクストリームプログラミングは、余計な設計ドキュメントを一切使用しないで、コード自体に語らせることを主張する。  
> ドキュメントはプロジェクトの活動に取り込まれていなくてはならない。

## モデルと実装を結びつける

良くないコードは、読んでも、システムの目的についての洞察を得ることは叶わない。

## モデル駆動設計

設計がドメインモデルに紐づいていないならば、そのモデルにほとんど価値はなく、ソフトウェアの正確性も疑わしい。

## レイヤードアーキテクチャ

4層に分離する話。
この辺りはクリーンアーキテクチャの話と共通する部分が多い。

- インターフェース層
- アプリケーション層
- ドメイン層
- インフラストラクチャ層

## ３種類のオブジェクト

- エンティティ（PKなどで同一性を確立できるもの）
- 値オブジェクト（何であるかだけが重視されるようなもの）
- サービス（操作がドメインの概念に関係しており、エンティティや値オブジェクトの自然な一部ではないもの。状態を持たない。）

## モジュール

> モジュール間では低結合、モジュール内では高凝集が必要

> モジュールをリファクタリングするのは、クラスをリファクタリングするよりも手間がかかり、混乱を招きもするので、それほど頻繁に行うことはできないだろう

複数のクラスを一つのモジュールに一緒に入れるということは、それらを一纏めに考えるよう他の開発者に伝えることを意味する。

> モデルが物語だとすれば、モジュールは章に相当する。モジュールの名前はその意味を伝える。

リファクタリングは、経験を基に、歯を食いしばって実行するしかない。

## しなやかな設計

ソフトウェアの最終的な目的はユーザーの役に立つことだが、それ以前に開発者の役に立たなければならない。  
開発者はその後何年もの間これを保守しなければならないが、そうしたいと思うだろうか？

> ソフトウェアの設計が明確でないと、開発者は現在の混乱した状態に目を向けることさえも恐れ、ましてや変更を加えるなどもってのほかだと考えるようになる。

> オーバーエンジニアリングの多くが、柔軟性の名の下に正当化されてきた。
> しかし、抽象化や間接化のためのレイヤを作りすぎてしまうと、邪魔になることの方が多い。

中身のコードを読まなければならないコンポーネントは、価値がない。

> クラスと操作には、効果と目的を記述する名前をつけ、約束したことを実行する手段には言及しないこと。

## デザインパターン

> 何がパターンで、何がそうでないかという解釈は、視点の影響を受ける。
> ある人にとってはパターンであるものも、別の人にとってはプリミティブ（基本的）な構成要素かもしれない。
