# リファクタリング 既存のコードを安全に改善する

リファクタリングのリファレンス翻訳本

リファクタリングが開発にとっていかに大切か、その必要性を説き、時にはどのように上司を説得するかのTipsにも触れる、といった内容になっている。

## 章立て

1. リファクタリングの例
2. リファクタリングの原則
3. コードの不吉な臭い
  - リファクタリングすべきタイミングについて
  - 明確な基準はないが、我々エンジニアは「リファクタリングが必要だと感じさせる臭いを嗅ぎ分ける能力を日頃から養って」おり、この直感に勝てるものは今のところ存在しない。
4. テストの構築
  - 自動テストの重要さについて触れている
5. カタログの紹介
  - リファクタリングの技法に名前を付けて分類することの意義の説明
  - 6章以降はこのカタログとなる
6. リファクタリングのはじめの一歩
7. カプセル化
8. 特性の移動
9. データの再編成
10. 条件記述の単純化
11. APIのリファクタリング

## コードの不吉な臭い

不吉な臭いには種類がある

- 不可思議な名前（名付けはプログラミング言語で最も難しい2つのことのうちの1つ）
  - 良い名前が思いつかないということは、設計が固まっていないことの示唆でもある
- 重複したコード
- 長い関数
- 長いパラメータリスト
  - パラメータオブジェクトの導入など
- グローバルなデータ
- 変更可能なデータ
  - スコープを絞ったり、値の変更用関数を用意したりする
- 変更の偏り
  - e.g. データベースとのやりとりを変更するときに複数箇所の処理に変更の必要が発生するべきではない
- 変更の分散
  - 変更を行うたびにあちこちのモジュールが少しずつ書き換わるような場合
- 特性の横恋慕
  - 外部のデータばかりアクセスしている困った関数
- データの群れ
  - データのまとまりはクラス定義にまとめていく
- 基本データ型への執着
  - オブジェクトによるプリミティブの書き換え
- 重複したスイッチ文
- ループ
  - パイプラインによるループの置換
- 怠け者の要素
  - メソッドが一つしかないクラス、本体に書かれた処理と同じ名前の関数、etc
- 疑わしき一般化
  - 将来必要になると予想しての余分な実装
- 一時的属性
  - 通常、オブジェクトは全ての属性を必要としていると考えるので、特定の状況でしか設定されない属性を持つクラスは非常に理解しにくくなる
- メッセージの連鎖
- 仲介人
  - 仲介しかしていないようなクラス
- インサイダー取引
  - 複数のクラスが密接に依存してしまう状態
- 巨大なクラス
- クラスのインターフェース不一致
- データクラス
  - ふるまいがないgetter/setterのみのデータクラスは存在自体が不吉
  - 例外として、setterのない普遍な値を扱うクラスは大丈夫
- 相続拒否
  - 不適切な継承
- コメント消臭剤
  - わかりにくいコードを補うためのコメント
  - 良いコメントの例
    - 不明点
    - なぜこのような処理を選択したか


### 基本的な考え

- 同時に変更する必要があるものはまとめる
- スコープを絞って影響範囲を明確にしていく


## 基礎用語

- プリミティブ
  - 基礎的な、原始的な
- ポリモーフィズム
  - プログラミング言語の持つ特性の一つ
  - 関数が引数や返り値の数や型などの異なる複数の実装を持ち、呼び出し時に使い分けるようにできること

