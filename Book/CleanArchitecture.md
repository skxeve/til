# Clean Architecture 達人に学ぶソフトウェアの構造と設計

[参考](https://www.amazon.co.jp/dp/B07FSBHS2V)

## アーキテクチャとは

> アーキテクチャの形状の目的は、そこに含まれるソフトウェアシステムの開発・デプロイ・運用・保守を容易にすることである。
> それらを容易にするための戦略は、できるだけ長い期間、できるだけ多くの選択肢を残すことである。

### 保守

> 保守は最もコストのかかるものである。
> 保守の主なコストは、洞窟探検とリスクだ。

それを理解すべき頃に、理解できている人間がいるならば、それは幸運である。

### あるべき姿

> 優れたアーキテクチャはユースケースを中心にしている。

ユースケースの役割について正しい認識をもってコーディングされているべき。

> アーキテクチャは、システムで使用しているフレームワークではなく、システムそのものについての情報を伝える必要がある。
> 例えば、ヘルスケアシステムを構築しているならば、新しく参加したプログラマがソースリポジトリを見た時に、「ああ、これはヘルスケアシステムだ」と思えるようにしておくべきである。

出会ってみたい。

### バウンダリー

ソフトウェアアーキテクチャにおいて、境界線を引く技芸。

> 境界線は「重要なもの」と「重要ではないもの」の間に引く

### 方針

> 方針の議論には、単一責任の原則（SRP）、オープン・クローズドの原則（OCP）、閉鎖性共通の原則（CCP）、依存関係逆転の法則（DIP）、安定依存の原則（SDP）、安定度・抽象度投下の原則（SAP）が混在している。

### アーキテクチャの決め方

> システムの最初のアーキテクチャを決めるための第一歩は、アクターとユースケースを見つけることだ。

最初に、利用者像と、求められる機能について考える。

> アクターとユースケースがわかったので、とりあえずのコンポーネントアーキテクチャを検討できるようになった。

利用者像と機能を元にコンポーネントアーキテクチャを検討できる。

### 検討すべきこと

> いくらうまい設計をしても、その実装方法の複雑さを考慮しなければ、あっという間に設計が崩れてしまう。
> チームの規模やメンバーのスキルやソリューションの複雑さ、そして時間と予算の制約などを考慮しよう。

チームで開発するのであれば、何も資料がなくてもソースコードから読み取れるようなアーキテクチャにするか、最低限の資料を作成するのが近道だろう。

## Component

> コンポーネントとは、デプロイの単位のことである。
> システムの一部としてリリースできる、最小限のまとまりを指す。

> コンポーネントは「関連する機能をよくできたクリーンなインターフェイスの向こう側に閉じ込めて、アプリケーションなどの実行環境の内側に置いたもの」

### コンポーネントの分け方

- 再利用・リリース等価の原則（REP）
> 再利用の単位とリリースの単位は等価になる。
- 閉鎖性共通の原則（CCP）
> 同じ理由、同じタイミングで変更されるクラスをコンポーネントにまとめること。
- 全再利用性の原則（CRP）
> 不要なものには依存しないこと。

この3原則は互いに相反する関係性を含んでいて、三角形で表現できる。
アプリケーションによって優先事項は異なる。バランスの取り方が腕の見せ所。

### 設計

> コンポーネントの構造をトップダウンで設計するのは不可能

### 循環依存について

原則として、循環依存があってはならない。
発生してしまった場合の解消方法は主に以下の2通り。
- 依存関係逆転の原則（DIP）を適用する。
- 新しいコンポーネントを作成し、両方のコンポーネントの依存先とする。

### 「安定度」という概念

- 多くから依存されているコンポーネントは安定度が高い。
依存されているものに対して責務を負っている状態と表現できる。
- 多くに依存しているコンポーネントは、安定度が低い。
依存先に対して従属している、と表現できる。
- 他に対して全く依存していないコンポーネントは、最も安定度が高く、他のコンポーネントの変更に影響を受けることがない。
これを独立していると表現できる。

#### 安定度・抽象度等価の原則（SAP）

- 安定度が高いものに、抽象度の高い実装を集めるべきである。
- 逆に安定度の低いものに、具体性の高い実装を集めるべきである。
- 安定度の高い方向に対して依存すべきである。

### メインコンポーネント

> 全てのシステムには、そのほかのコンポーネントを作成・調整・監督するコンポーネントが少なくとも１つ存在する。私はこのコンポーネントをMainと呼んでいる。

main関数ですね。

> 依存関係については、このMainコンポーネントにDIフレームワークを使って注入する必要がある。
> Mainに注入できたら、あとはフレームワークを使用せずに、Mainが通常のやり方で依存関係をちりばめる。

## Entity

> エンティティとは、コンピュータシステムの内部にあるオブジェクトであり、最重要ビジネスデータを操作する最重要ビジネスルールをいくつか含んだものである。
> エンティティオブジェクトには、最重要ビジネスデータかそれらのデータへの簡単なアクセス手段が含まれる。
> エンティティのインターフェイスは、そうしたデータを操作する最重要ビジネスルールを実装した関数で構成されている。

ドメイン駆動設計（DDD）におけるドメインと同じようなもの、らしい。

> エンティティは、メソッドを持ったオブジェクトでも、データ構造と関数でも構わない。

> エンティティはアプリケーションのオブジェクトになるだろう。

## Usecase

> ユースケースはアプリケーション固有のビジネスルールを記述している。
> ユースケースは、ユーザーインターフェイスについては記述していない。

インターフェイスはコントローラーとかViewとかの役割。

> ユースケースは、エンティティに入出力するデータの流れを調整し、ユースケースの目標を達成できるように、エンティティに最重要ビジネスルールを使用するように指示を出す。

### エンティティとの関係

> エンティティは自身を制御するユースケースのことを知らない。
> 下位レベルのユースケースは、上位レベルのエンティティのことを知っている。

内側から作成していくのが楽そう。

## クリーンアーキテクチャ

> ソースコードの依存性は、内側（上位レベルの方針）だけに向かっていなければならない。

1層（最上位）：エンティティ
2層：ユースケース
3層：コントローラー、ゲートウェイ、プレゼンター
4層（外部インターフェイス）：デバイス、DB、UI、ウェブ

### プレゼンター

> プレゼンターは、Humble Objectパターンの一種であり、アーキテクチャの境界の特定と保護に役立つものである。

#### Humble Objectパターン

> Humble Objectパターンは、ユニットテストを実行する人が、テストしにくい振る舞いとテストしやすい振る舞いを分離するために生み出されたデザインパターンである。

### データベースゲートウェイ

> ユースケースインタラクターとデータベースの間にあるのが「データベースゲートウェイ」である

SQLとかが閉じ込められるのが、おそらくこの層。

## テスト

> テストはシステムの一部だ。

本番環境にはデプロイしないだけ。

## フレームワーク

フレームワークは詳細であり、クリーンアーキテクチャ上では外側に位置するものだし、位置しなければならない。

> フレームワークなんかと結婚するな！

## 他のアーキテクチャ

> レイヤードアーキテクチャはビジネスドメインに関して何も叫ばない。
> まったく異なる２つのビジネスドメインのコードをそれぞれレイヤードアーキテクチャにして並べてみると、気味が悪いほどそっくりになる。

逆に言うなら、クリーンアーキテクチャにして並べると、そっくりにはならない、という話になる。


# 感想

- TDDをはじめとしたテスト重視の発想と相性が良さそうなアーキテクチャだと感じた。
- 実際のソースコードのディレクトリ構造や名前空間の構成が想像しにくい。サンプル的なコードを見てみる必要がありそう。
- Interface地獄になりそう。
- 実装コスト高そう。
- 考え方としては参考になるものが多かった。
